<?php
class FilterBaseSection {
	/**
	 * Base class for all sections
	 */
	function __construct($filter, $name, $options) {
		/** Name of section */
		$this->name = $name;
		/** Parent Filter object */
		$this->filter = $filter;
		/** Selected choices for the section */
		$this->values = null;

		/** Forced values **/
		$this->fixed = null;

		if(isset($filter->options['section'][$name])) {
			$options+= $this->filter->options['section'][$name];
		}
		$options = $options + [
			'join' => null,     //list of SqlJoins - joins of tables that must be active for queries generated by this filter section
			'dbmole' => null,                  //database access object
			'main_table_fields' => [], //additional fields used from the main (filtered) table
			'rank' => null,
			'visible' => true,
			'fixed' => null,
			'landing_page' => $filter->options['default_landing_page'], /*
			            true/false : does/does not prevent other sections l.p. object to match if this section is filtered
									object: if just one landing page object from all sections matches, it is a landing page. */
		];

		$this->visible = $options['visible'];

		foreach(array_diff_key($options, ['form_field' => false, 'form_field_options' => false]) as $k=>$v) {
				if(substr($k,0,5)=='form_' && $v!==null) {
					$options['form_field_options'][substr($k,5)] = $v;
					unset($options[$k]);
				}
		}
		$this->options = $options;

		if($this->options['join']) {
			$join = $this->options['join'];
			if(!is_array($join)) {
				$join = [ $join ];
			}
			foreach($join as &$j) {
				if(is_object($j)) {
					$j = $j->getName();
				}
			}
			$this->joins  = $join;  //joins, that should be enabled when queries for the section are run
		} else {
			$this->joins = [];
		}

		$this->filter->add($this);
		if($this->options['fixed']!==null) {
			$this->setFixed($this->options['fixed']);
		}

		if(is_object($this->options['landing_page'])) {
			$this->options['landing_page']->setSection($this);
		}
	}

	function isVisible() {
		return $this->visible;
	}

	function landingPage() {
		if($this->fixed || !$this->isFiltered() || !$this->options['landing_page']) {
			return false;
		}
		if(is_object($this->options['landing_page']) && $this->options['landing_page']->isLandingPage($this)) {
			return $this->options['landing_page'];
		}
		return true;
	}

	function getRank() {
		return $this->options['rank'];
	}

	/** Is given field name from main table or not?
	 * Return field name stripped from table name or FALSE
   **/
	function fieldIsFromMainTable($field) {
		if(($pos = strpos($field,'.'))!==false) {
			$table = trim(substr($field, 0, $pos));
			return $table == $this->filter->getMainTableName()?trim(substr($field, $pos+1)):false;
		} else {
			return $this->joins?false:trim($field);
		}
	}

	/***
	 * Returns all fields from main table,
	 * that are needed by this section. {@see getUsedFields}
   **/
	function getMainTableFields() {
		$out = $this->options['main_table_fields'];
		foreach($this->getUsedFields() as $field) {
			if( $this->fieldIsFromMainTable($field) ) {
				$out[] = $field;
			}
		}
		return $out;
	}


	/***
	 * Returns all fields that are needed by this table
   **/
	function getUsedFields() {
		return [ $this->options['field'] ];
	}


	/**
	 * Names of joins used by filter
	 */
	function getJoinNames() {
		return $this->joins;
	}

	/** Parse method has been called? */
	function isParsed() {
		return $this->values !== null;
	}

	/** Parse method has been called and some conditions on this section has been required */
	function isFiltered() {
		return $this->isParsed() && $this->values;
	}

	/* Name of section */
	function getName() {
		return $this->name;
	}

	/**
	 * Name of parameter (e.g. name of form field, or key for
	 * array given as argument in $this->parse method),
	 * that will be used for this section.
	 * $filter = new Filter(['prefix' => 'f_');
	 * $section = new FilterSection($filter, 'brands', .....);
	 * $section->getParamName();
	 * >> f_brands
	 */
	function getParamName() {
		return $this->filter->options['prefix'] . $this->name;
	}

	//INTERNAL METHODS

	/** Return database access object */
	function getDbMole() {
		return $this->filter->getDbMole();
	}

	/** Return options for SQLCondition object used in queries generated by the section */
	function sqlOptions($disable_where = false) {
		$out = [
			'active_join' => $this->joins,
		];
		if($this->joins) {
			$out['override_join'] = [ reset($this->joins) => 'JOIN'];
		}
		if($disable_where) {
			$out['disable_where'] = $this->name;
		}
		return $out;
	}

	/**
	 * Returns SQLCondition object, where the conditions should be applied.
	 */
	function getMainJoin($sql=null) {
		$sql = $sql?:$this->filter->filteredSql;
		if($sql && $this->joins) {
			$sql = $sql->getJoin(reset($this->joins));
		}
		return $sql;
	}

	/***
	Return params as they should appear in SQL
	*/
	function getParams() {
		return $this->values?[$this->getParamName() => $this->values]:[];
	}

	/**
	Return values for given filter either enforced (fixed) or user given
	*/
	function getValues() {
		return $this->fixed === null ? $this->values : $this->fixed;
	}

	/*
	 * Parse values and add apropriate conditions (e.g. from form)
	 * Called by Filter::parse()
	 */
	function parse($values) {
		$this->parseValues($values);
		$values = $this->getValues();
		$this->addConditions($values);
		return $this->values;
	}

	/**
	 * Set fixed values for the filter: fixed values means that items are filtered
	 * according the fixed values, and no form control is rendered.
	 */
	function setFixed($values) {
		$this->fixed = $values;
		$this->addConditions($values, $this->filter->unfilteredSql);
	}

	/**
	 * Is the filter fixed (and thus disabled for the user)?
	 */
	function isFixed() {
		return $this->fixed;
	}

	/**
	 * Create a form field(s) for current section
	 *
	 * foreach($section->createFormFields() as $field) {
	 *   $form->add_field($field);
	 * }
	 */
	function createFormFields() {
		$out = [];

		$class = $this->options['form_field'];
		if($this->fixed===null && $class && $this->isPossible()) {
			$name = $this->getParamName();
			$out[$name] = new $class(
				$this->getFieldOptions()
			);
		}
		return $out;
	}

	function getFieldOptions() {
		return [
			'filter_section' => $this,
			'initial' => $this->values,
			'required' => false
		] + $this->options['form_field_options'];
	}

	/**
	 * Return SQL full name of filtered field
	 * $brands = $filter->addJoin('brands', .... );
	 * $section = new FilterSection($filter, 'name', ['field' => 'id', join => $brands ]);
	 * $section->getSqlField()
	 * > 'cards.id'
	 */
	function getSqlField($field = 'field') {
		$field = $this->options[$field];
		if(preg_match('/^[a-z0-9_]+$/', $field)) {
			$field = "{$this->getMainJoin($this->filter->unfilteredSql())->getTableName()}.$field";
		}
		return $field;
	}

	/**
	 * Add conditions to ParsedSqlResult based on given values
	 **/
	function addConditions($values, $sql=null) {
		if(!$values) { return; }
		list($condition, $bind) = $this->getConditions($values);
		if($condition) {
			$sql = $this->getMainJoin($sql);
			$sql->namedWhere($this->name, $condition)->bind($bind);
		}
	}
}
