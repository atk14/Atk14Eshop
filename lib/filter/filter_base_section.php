<?php
class FilterBaseSection {
	/**
	 * Base class for all sections
	 */
	function __construct($filter, $name, $options) {
		/** Name of section */
		$this->name = $name;
		/** Parent Filter object */
		$this->filter = $filter;
		/** Selected choices for the section */
		$this->values = null;

		/** Forced values **/
		$this->fixed = null;

		$options = $options + [
			'join' => null,     //list of SqlJoins - joins of tables that must be active for queries generated by this filter section
			'dbmole' => null,                  //database access object
			'main_table_fields' => [], //additional fields used from the main (filtered) table
			'rank' => null
		];

		foreach(array_diff_key($options,
				['form_field' => false, 'form_field_options' => false]) as $k=>$v) {
				if(substr($k,0,5)=='form_' && $v!==null) {
					$options['form_field_options'][substr($k,5)] = $v;
					unset($options[$k]);
				}
		}
		$this->options = $options;

		if($this->options['join']) {
			$join = $this->options['join'];
			if(!is_array($join)) {
				$join = [ $join ];
			}
			foreach($join as &$j) {
				if(is_object($j)) {
					$j = $j->getName();
				}
			}
			$this->joins  = $join;  //joins, that should be enabled when queries for the section are run
		} else {
			$this->joins = [];
		}

		$this->filter->add($this);
	}

	function getRank() {
		return $this->options['rank'];
	}

	/** Is given field name from main table or not?
	 * Return field name stripped from table name or FALSE
   **/
	function fieldIsFromMainTable($field) {
		if(($pos = strpos($field,'.'))!==false) {
			$table = trim(substr($field, $pos));
			return $field == $this->filter->emptySql->getTableName()?trim(substr($field, pos+1)):false;
		} else {
			return $this->joins?false:trim($field);
		}
	}

	/***
	 * Returns all fields from main table,
	 * that are needed by this section. {@see getUsedFields}
   **/
	function getMainTableFields() {
		$out = $this->options['main_table_fields'];
		foreach($this->getUsedFields() as $field) {
			if( $f=$this->fieldIsFromMainTable($field) ) {
				$out[] = $field;
			}
		}
		return $out;
	}

	function stripFieldName($field) {
			 if(strpos($field, ')')) {
				return null;
			 }
       $field = trim($field);
       $field = preg_replace('/\s(DESC|ASC)$/i','', $field);
			 $field = preg_replace('/^NOT\s/i','', $field);
			 return $field;
	}

	function stripFieldNames($fields) {
		   return array_filter(array_map([$this, 'stripFieldName'], $fields));
	}

	/***
	 * Returns all fields that are needed by this table
   **/
	function getUsedFields() {
		return [ $this->options['field'] ];
	}


	/**
	 * Names of joins used by filter
	 */
	function getJoinNames() {
		return $this->joins;
	}

	/** Parse method has been called? */
	function isParsed() {
		return $this->values !== null;
	}

	/** Parse method has been called and some conditions on this section has been required */
	function isFiltered() {
		return $this->isParsed() && $this->values;
	}

	/* Name of section */
	function getName() {
		return $this->name;
	}

	/**
	 * Name of parameter (e.g. name of form field, or key for
	 * array given as argument in $this->parse method),
	 * that will be used for this section.
	 * $filter = new Filter(['prefix' => 'f_');
	 * $section = new FilterSection($filter, 'brands', .....);
	 * $section->getParamName();
	 * >> f_brands
	 */
	function getParamName() {
		return $this->filter->options['prefix'] . $this->name;
	}

	//INTERNAL METHODS

	/** Return database access object */
	function getDbMole() {
		return $this->filter->getDbMole();
	}

	/** Return options for SQLCondition object used in queries generated by the section */
	function sqlOptions($disable_where = false) {
		$out = [
			'active_join' => $this->joins
		];
		if($disable_where) {
			$out['disable_where'] = $this->name;
		}
		return $out;
	}

	/**
	 * Returns SQLCondition object, where the conditions should be applied.
	 */
	function getMainJoin($sql=null) {
		$sql = $sql?:$this->filter->parsedSql;
		if($sql && $this->joins) {
			$sql = $sql->getJoin(reset($this->joins));
		}
		return $sql;
	}

	/***
	Return params as they should appear in SQL
	*/
	function getParams() {
		return $this->values?[$this->getParamName() => $this->values]:[];
	}

	/**
	Return values for given filter either enforced (fixed) or user given
	*/
	function getValues() {
		return $this->fixed === null ? $this->values : $this->fixed;
	}

	/*
	 * Parse values and add apropriate conditions (e.g. from form)
	 * Called by Filter::parse()
	 */
	function parse($values) {
		$this->parseValues($values);
		$values = $this->getValues();
		$this->addConditions($values);
		return $this->values;
	}

	/**
	 * Set fixed values for the filter: fixed values means that items are filtered
	 * according the fixed values, and no form control is rendered.
	 */
	function setFixed($values) {
		$this->fixed = $values;
		$this->addConditions($values, $this->filter->emptySql);
	}
}
