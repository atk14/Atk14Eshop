<?php

/**
 * Section of filter, that has checkboxes
 * abstract, descendant are
 * FilterSection - for filter choices given by possible values of a sql field
 * FilterFlagSection - for filter choices given by boolean (sql) fields
 */
abstract class FilterChoiceSection extends FilterBaseSection {

	function __construct($filter, $name, $options) {
		$options = $options + [
			'force_choices' => false, #If true, choices in form are not generated from DB, but just
																#used as given in options in $this->options['form_field_options']['choices']
			#forms framework support
			'form_field' => 'FilterMultipleChoiceField',                  # name of FormField to be created by createFormFields
			'form_field_options' => [ 'label' => $name, 'choices' => [] ],# options passed to createFormFields

			#commonly no need to redefine
			'condition_over_subtable' => null, //whether the condition is over subtable or not - default is (bool) join
			'multiple' => true								 //user can select multiple values
		];
		parent::__construct($filter, $name, $options);
		$this->choiceLabels = $this->options['form_field_options']['choices'];
		$this->forceChoices = $this->options['force_choices'];

		$this->possibleChoices = null;         //cache for choices
		$this->availableChoices = null;         //cache for choices
		$this->availableCounts = null; //cache for availableCounts

		if($this->options['condition_over_subtable'] === null) {
			$this->options['condition_over_subtable'] = (bool) $this->options['join'];
		}
	}

	/**
	 * Returns array of choices generated by the section
	 * for at least one record exists, where no filter is applied.
	 * $section->getPossibleChoices();
	 * >> [ 1, 6, 15 ]
	 */
	function getPossibleChoices() {
		if($this->forceChoices) {
			$this->possibleChoices = array_keys($this->getChoiceLabels());
		}
		if(!$this->possibleChoices) {
			$this->possibleChoices = $this->getChoicesOn($this->filter->emptySql());
		}
		return $this->possibleChoices;
	}

	/**
	 * Returns array of choices generated by the section,
	 * for which at least one record matches the currently choosed
	 * filter conditions.
	 * $section->getAvailableChoices();
	 * >> [ 1, 15 ]
	 */
	function getAvailableChoices() {
		if($this->availableChoices === null) {
			if($this->forceChoices || array_diff_key($this->filter->getParams(), [$this->getParamName() => 0])) {
				$this->availableChoices = $this->getChoicesOn(
					$this->filter->parsedSql
				);
			} else {
				$this->availableChoices = $this->getPossibleChoices();
			}
		}
		return $this->availableChoices;
	}

	/**
	 * Returns array of items count (for empty filter)
	 * $section->getPossibleCount();
	 * >> [ 1 => 10, 15 => 7 ]
	 * There is 10 items for brand with id 1 and 7 for brand 15.
	 */
	function getPossibleCounts() {
		return $this->getCountsOn($this->filter->emptySql()->result());
	}

	/**
	 * Returns array of count of items that match the filter.
	 * (the counts can be limited by other filter's sections)
   *
	 * If $this->isFiltered() (some option in this filter section is checked)
	 * then the result is number of items, that will be shown IN ADDITION
	 * to the current selection (negative number means, that the choice
	 * lower the number of items in selection - e.g. when FilterFlagSection
   * has AND operator between the choices)
   *
	 * $section->getAvailableCount();
	 * >> [ 1 => 4, 15 => 2 ]
	 * There is only 4 items for brand with id 1 and 2 for brand 15,
	 * the others do not fill the filter requirements.
	 */
	function getAvailableCounts() {
		if(!$this->availableCounts) {
			$counts = $this->countAvailable();
			if($this->values) {
				$no = $this->getPossibleChoices();
				$counts += array_fill_keys(array_keys(array_diff_key(array_flip($no), $counts)),null);
			}
		  $this->availableCounts = $counts;
		}
		return $this->availableCounts;
	}

	/**
	 * Return the array of choices, that should be disabled: the choices,
	 * which selection results in empty (filtered) set and not chosen in filter.
   */
	function getDisabledChoices() {
		if(!$this->isParsed()) {
			return [];
		}
		$available = array_flip($this->getAvailableChoices());

		if($this->values) {
			$available += array_flip($this->values);
		}
		return array_flip(array_diff_key(
			array_flip($this->getPossibleChoices()), $available
		));
	}

	function getChoices($options = []) {
		$options += [
			'counts' => true,
			'empty_string' => '%s (%s)',
			'unselected_string' => '%s (%+d)',
		];
		$out = $this->getChoiceLabels();
		if(!$this->forceChoices) {
			$choices = $this->getPossibleChoices();
			$choices = array_combine($choices, $choices);
			$out = array_intersect_key($out + $choices, $choices);
		}

		if($options['counts'] && $this->isParsed()) {
			$cnts = $this->getAvailableCounts();
			$count = $this->filter->getAllRecordsCount();
			if($this->values) {
				$count -= $this->filter->getRecordsCount();
			}
			if($this->values && $this->options['multiple']) {
				$str = $options['unselected_string'];
			} else {
				$str = $options['empty_string'];
			}
			foreach($cnts as $k => $v) {
				if($v == $count) {
					unset($out[$k]);
				} elseif($v) {
					$out[$k] = sprintf($str,$out[$k], $v);
				}
			}
		}
		return $out;
	}

	/**
	 * Create a form field(s) for current section
	 *
	 * foreach($section->createFormFields() as $field) {
	 *   $form->add_field($field);
	 * }
	 */
	function createFormFields() {
		if($this->fixed) {
			return [];
		}
		$name = $this->getParamName();
		$class = $this->options['form_field'];
		$out = [];
		if($class && $this->getPossibleChoices()) {
			$out[$name] = new $class(
				$this->options['form_field_options'] +
											['filter_section' => $this]
			);
		}
		return $out;
	}

	/**
	 * Set choice labels, used in $this->getChoices()
	 * If the labels is not set, they are readed from database (for FilterSection),
	 * or the ids of choices are used (for FilterFlagsSection)
	 */
	function setChoiceLabels($labels) {
		$this->choiceLabels = $labels;
	}

	/**
	 * Return choice labels, either user defined or already generated
	 */
	function getChoiceLabels() {
		return $this->choiceLabels;
	}

	/** Generate counts for FilterBaseSection::getAvailableCount
	 *  (getAvailableCounts take care of caching and filling missing items
   *  this method just counts and can be redefined)
	 */
	function countAvailable() {
		$sql = $this->filter->parsedSql();
		if($this->values) {
			if($this->options['condition_over_subtable'] && $this->options['multiple']) {
				//condition over subtable, so we must compute
				//two sets and subtract
				$result = $sql->result(
					$this->sqlOptions(true)
				);
				$notIn = $sql->result( $this->sqlOptions());
				$notIn = $this->filter->result();
				$idField = $this->filter->getIdField();
				$notIn = $notIn->select("$idField", ['add_options' => false]);
				$result->andWhere("$idField NOT IN \n( $notIn )");
			} else {
				//condition over table, so just WHERE NOT is sufficient
				$options = $this->sqlOptions();
				if($this->options['multiple']) {
					$options['not_where'] = $this->name;
				} else {
					$options['disable_where'] = $this->name;
				}
				$result = $sql->result($options);
			}
		} else {
			$result = $sql->result(
				$this->sqlOptions()
			);
		}
	  return $this->getCountsOn($result);
	}

	/**
	 * Parse values (from form)
	 */
	function parseValues($values) {
		$pname = $this->getParamName();
		$this->availableCounts = null;
		$this->availableChoices = null;
		if(!key_exists($pname, $values)) {
			$this->values=[];
		} else {
			$this->values = $values[$pname];
		}
		return $this->values;
	}

	/**
	 * @param All params of filter
	 * @return array [ ['params' => (array of filter params with given element removed), 'label' => 'label'] ] of active filters.
	 **/
	function getActiveFilters($params) {
		if(!$this->values) {
			return [];
		}

		$pname = $this->getParamName();
		$myParams = $this->values;

		if(count($this->values) == 1) {
			unset($params[$pname]);
			return [[
				'params' => $params,
				'label' => $this->getChoices(['count' => false])[current($this->values)]
			]];
		}

		$out = array_intersect_key($this->getChoices(['count' => false]), array_fill_keys($this->values, true));
		$copy = $out;
		array_walk( $out, function(&$val, $key) use ($pname, $copy, $params) {
			$mod = $copy;
			unset($mod[$key]);
			$val = [
			'params' => [ $pname => array_keys($mod) ] + $params,
			'label' => $val
		] ; });
		return $out;
	}

	function setFixed($values) {
		if(!is_array($values )) {
			$values = [ $values ];
		}
		parent::setFixed($values);
	}
}
